---
layout: post
title:  "What does an enterprise grade Spring Boot application look like in 2023"
date:   2023-04-2 
categories:  Spring Boot , SaaS , Enterprise Software
---

## Abstract


A frequent ask from younger developers & college students on [r/SpringBoot](https://www.reddit.com/r/SpringBoot/) goes along the lines of
"I've done xyz tutorials, what does a  *real* Spring Boot application look like ? "

Or, newer engineers joining an enterprise might ask - why is this the way it is? 

Having built enterprise applications in SpringBoot since 2017, I'll share some insights to hopefully fill in some blanks. 
In this article, I'll make a lot of generalisations for the purpose of giving a single coherent idea,
and refer to an example I've implemented on [GitHub](https://github.com/petebids/todo-tx-outbox). Note that this piece of code is far from perfect, & only exists to give an idea of what an enterprise grade app might look like.

My goal is that by the end of reading this article, folks who have worked through some 
SpringBoot tutorials will have some insight on the next steps of the self-guided learning



## Security

Generally speaking, new enterprise applications are built in a microservices style, & implement the [Resource server](https://www.rfc-editor.org/rfc/rfc6749#section-1.1) pattern.

![Diagram](/assets/authn.png)


What this means is that a central team builds and or runs some SaaS or a custom implementation of the OIDC protocol that plays the role of the authorization server. 
When you start building a new service, you add the resource server dependency (or some internal library that performs the same purpose) & apply some minimal configuration - you generally don't have to model the concept of users, & supply login endpoints yourself in a microservices architecture




<script src="https://gist.github.com/petebids/cdbec8953b054688c67cf76730635665.js"></script>

<script src="https://gist.github.com/petebids/1e710e7bc60aa1b9fceefad966b6ec10.js"></script>




## Contract first development

Generally, when you are building an API in an enterprise environment, you are not the only party interested in your api contract.
Frontend engineers, Product managers & Architects will all be a part of the outer design of your service.
As such, when a new feature needs to be added, you will spend time drawing up the interactions on a whiteboard or a design tool , then codifying them into your service contracts. 
Once everyone agrees on the contract, you can all go off & undertake parallel development - you build your api, while other teams mock your api & build their integration

The basic process flow is documented here, but for the sake of clarity within our example 
![Diagram](/assets/todo_codegen.png)

The contract
<script src="https://gist.github.com/petebids/91d3609f7ceb143ec98a479bb6e33614.js"></script>
the maven plugin configuration
<script src="https://gist.github.com/petebids/36a3d2f89d7b63f682acf9779e608615.js"></script>
the skeleton code generated by the Maven plugin 
<script src="https://gist.github.com/petebids/a22508e730ffa45f4c4427b378bf4692.js"></script>
the actual application code written by the engineer
<script src="https://gist.github.com/petebids/3dbad4c3fbc5285da773ac77dbc81c12.js"></script>





## Package structure & Code style

Generally speaking, Enterprise code tries to be as a structured  & formulaic as possible, for the purpose of [low cognitive load](https://en.wikipedia.org/wiki/Cognitive_load)
There are good reasons for this, as it means reshuffling service ownership amongst teams or helping another team out in a crisis becomes easier, if everyone's code looks the same
If you are working on something new & feeling overwhelmed, it's much easier knowing which package classes belong in, or how to structure a new feature

This is just an example of an enterprise structure
```shell
❯ tree src/main/java/xyz/petebids/todotxoutbox -L 2
src/main/java/xyz/petebids/todotxoutbox
├── TodoTxOutboxApplication.java
├── application
│   ├── kafka
│   ├── metrics
│   └── rest
├── domain
│   ├── Constants.java
│   ├── command
│   ├── mapper
│   ├── model
│   └── service
└── infrastructure
    ├── entity
    ├── event
    └── repository


```
This structure borrows from domain driven design & the layered cake style, but I'll go over a few quick points

![Diagram](/assets/layerd_packages.png)

- The Application layer
  - The code in this layer is representative of the pieces of our application that are exposed to the outside world for our service to be invoked,
    in this case our REST API & Kafka Consumers
- The Domain layer
  - this covers your business logic - the core of the application
- The Infrastructure layer 
  - this covers the dependencies of the app, the things the application calls 

and the following pattern should be followed

- infra code should be used in the infra and domain layers
- domain code should be used in the domain and application layers
- infra code should not be used in the application layer


This is contrary to the typical tutorial code that exposes JPA Entities over REST -
allowing rapid refactoring via the separation of concerns & the S, I & D in [SOLID](https://en.wikipedia.org/wiki/SOLID)




## 12 Factor apps

The 12 factor principles are a standard for building backend applications for the modern web. It's important to [read and understand](https://12factor.net/) 
why in the abstract before trying to implement these practices in your spring application.


# We don't use the @Scheduled annotation

Whilst the scheduled annotation is a powerful tool with low overhead, it adds some state into your application that is antithetical with a 12 factor app. 
If you deploy in a horizontally scaled manner, there may be  2, 10, or 200 instances of your application at any given time, 
and those instances can & will bve shutdown at any time. 
If you only want a @Scheduled job to run once, you need to implement leader election,
& deal with the potential of race conditions of scheduled jobs & container shutdown,. 

Instead, the invocation of a scheduled process is extracted from the application, & the scheduled method is exposed via REST.
Tracking the schedule over 
When the scheduled time passes, the scheduler calls the Service via the load balancer, and the load balancer finds an active pod 

TODO diagram


# Docker Compose for local development 

To fulfil the [dev/prod parity](https://12factor.net/dev-prod-parity) principle, [Docker Compose](https://docs.docker.com/compose/) is frequently used.

In this example, our service depends on a database, keycloak, kafka, schema registry and kafka connect. 
Using docker compose, it's trivial to spin up ephemeral copies of these services, to give each engineer a realistic local development environment.
<script src="https://gist.github.com/petebids/80a62ec3e1f0f6533d468e4ea1bdfc02.js"></script>

# Conclusion

Thanks for reading, I hope you found this helpful.